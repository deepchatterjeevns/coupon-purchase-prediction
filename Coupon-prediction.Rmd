---
title: "Coupon Prediction"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(dplyr)
```

```{r}
dir <- './data/'
area_train <- read.csv(paste0(dir,"coupon_area_train_en.csv")) #translated to en
list_train <- read.csv(paste0(dir,"coupon_list_train_en.csv")) #translated to en
user_list <- read.csv(paste0(dir,"user_list_en.csv"), na.strings=c("", NA))
pref_location <- read.csv(paste0(dir,"prefecture_locations.csv"))
visit <- read.csv(paste0(dir,"coupon_view_3months.csv"))

detail_train <- read.csv(paste0(dir,"coupon_detail_train_en.csv"))

# not using:
# colnames(detail_train$SMALL_AREA_NAME) change col name to residential small area
# list_test <- read.csv(paste0(dir,"coupon_list_test.csv"))
# visit_train <- read.csv(paste0(dir,"coupon_visit_train.csv")) # big file
# visit_train <- visit_train[visit_train$PURCHASE_FLG!=1,c("VIEW_COUPON_ID_hash","USER_ID_hash")]
```

## Understanding coupon area train data
each COUPON_ID_hash can have multiple rows. selecting one example of COUPON_ID_hash reveals that each coupon can be listed for multiple locations.
```{r}
sum(duplicated(area_train$COUPON_ID_hash))
head(area_train[duplicated(area_train$COUPON_ID_hash),])
area_train[area_train$COUPON_ID_hash == "7d1ce87a632bc4a57cfb4fc4a895cced",]

# one coupn can be listed in more than one prefecture
head(table(area_train$COUPON_ID_hash,area_train$PREF_NAME))
```

## Understanding coupon list train
This dataset contains characteristics of each coupon.
There are no duplicates. Each row is one coupon.
There is location information (ken, small area name, large area name) for each coupon in this data set. But each coupon can have multiple locations as seen in area_train. How is the location determined in list_train?
```{r}
head(list_train)
sum(duplicated(list_train$COUPON_ID_hash))

# looking at the same coupon ID as in area_train, the location in list_train is one of the many locations in area_train.
list_train[list_train$COUPON_ID_hash == "7d1ce87a632bc4a57cfb4fc4a895cced",]
# ken = Hyogo Prefecture

```

## Coupon Detail train
This data set contains purchase log of users.
A quick look at the data reveals that one user can purchase the same coupon of the same location at different times, each generating a row in this data set.
What happens when a user purchases the same coupon at two locations at the same time? does this generate two rows or one row?

```{r}
head(detail_train)
head(detail_train[duplicated(detail_train$USER_ID_hash),])

```

## test set is a different set of coupons from train

## are the test coupons in the view log?

## Understanding User list
Prefecture (not small area) is provided
```{r}
head(user_list)
str(user_list)
```

## Data cleaning/wrangling
Rename columns to differentiate user and coupon prefecture
```{r}
names(user_list)[names(user_list)=="en_pref"] <- "user_pref"
names(list_train)[names(list_train)=="en_ken"] <- "coupon_pref"
```

Selecting more relevant columns to reduce dataframe size
```{r}
list_train <- subset(list_train, select=c(COUPON_ID_hash,en_capsule,en_genre,PRICE_RATE,CATALOG_PRICE,DISCOUNT_PRICE,VALIDPERIOD,en_small_area,coupon_pref))
user_list <- subset(user_list,select = c(USER_ID_hash,AGE,SEX_ID,user_pref))
```

There are missing prefecture data in user_list. Why are there missing residential addresses? Have these users purchased something?
```{r}
cat(sum(is.na(user_list$user_pref)), "users with missing pref location\n")
# Checking if all purchased coupons have a user residential area name

cat("purchases without user residential area recorded:", sum(is.na(detail_train$SMALL_AREA_NAME)),"\n" )
# no NAs, every coupon purchase has a user residential area recorded

cat(sum(user_list[is.na(user_list$user_pref), "USER_ID_hash" ] %in% unique(detail_train[!is.na(detail_train$SMALL_AREA_NAME), "USER_ID_hash"])), "users without pref name in user_list but has small area residential name in detail_train\n")

# sum( unique(detail_train[!is.na(detail_train$SMALL_AREA_NAME), "USER_ID_hash"] %in% user_list[is.na(user_list$user_pref), "USER_ID_hash" ]))

```
Can we use SMALL_AREA_NAME to get prefecture name for the users without a residential prefecture recorded? SMALL_AREA_NAME is the "User redidential area name" according to Kaggle Data page, but a quick check revealed that the same user can be listed in multiple locations on the purchase log, yet have no registered address in the user list. How could that be?

```{r}
head(detail_train[,c("USER_ID_hash", "SMALL_AREA_NAME")], n=10)
```

Browsing some coupon pages revealed that coupons like restaurant discount tickets or physical products have to be delivered to an address.

```"Discount ticket" will be delivered to the designated address at the time of purchase by "Kuroneko DM flight"```

That explains multiple small areas associated with each user. Coupons could be delivered either to the user's or friend's/family's address. With this in mind, we can fill up missing prefectures in user_list using the most common prefecture the coupons are delivered to.

```{r}
# Get (small area name - prefecture name) association from list_train
small.area.pref <- unique(list_train[,c("en_small_area", "coupon_pref")])

# Merge with detail train to get prefecture for small area
detail_train <- merge(detail_train, small.area.pref, by.x = "en_SMALL_AREA_NAME", by.y = "en_small_area", all.x = TRUE)

# Get most frequent prefecture for each user from purchase log
getmode <- function(v) {
   uniqv <- unique(v)
   uniqv[which.max(tabulate(match(v, uniqv)))]
}

mode.pref <- detail_train %>% 
  group_by(USER_ID_hash) %>%
  summarize(mode.pref = getmode(coupon_pref))

user_list <- merge(user_list, mode.pref, by = "USER_ID_hash", all.x = TRUE)

user_list$user_pref <- as.character(user_list$user_pref)
user_list$mode.pref <- as.character(user_list$mode.pref)
user_list$user_pref <- ifelse(is.na(user_list$user_pref), user_list$mode.pref, user_list$user_pref)
user_list$mode.pref <- NULL
```

# Preparing data for modeling
Rows from view log contain multiple of the same coupon-user pair, because each user can view multiple times then eventually purchase during another session, each recorded as one row.
Summarizing into unique coupon-user pairs, in that users who eventually bought will be classified as purchased.
```{r}
visit.info<- visit %>%
  group_by(VIEW_COUPON_ID_hash,USER_ID_hash)%>%
  summarise(purchase = max(PURCHASE_FLG))
```

merge visit, user characteristics, coupon characteristics
```{r}
dat <-merge(list_train,visit.info, by.x = "COUPON_ID_hash",by.y = "VIEW_COUPON_ID_hash")
dat <-merge(dat, user_list, by="USER_ID_hash")
```

# Feature Engineering
most frequently visited genre
```{r}
mode.genre <- dat %>% 
  group_by(USER_ID_hash) %>%
  summarize(mode.visit.genre = getmode(en_genre))

dat <- merge(dat, mode.genre,by = "USER_ID_hash",all.x = TRUE)
```

distance between user and coupon default prefecture
```{r}

```

distance between user and coupon nearest branch prefecture
```{r}

```

number of times coupon viewed
```{r}

```


## Split into test and train dataset
```{r}
set.seed(123)
sample <- sample(c(TRUE, FALSE), nrow(dat), prob=c(0.7,0.3), replace=TRUE)
train <- dat[sample,]
test <- dat[!sample,]

write.csv(train, paste0(dir,"visit_train.csv"), row.names = F)
write.csv(test, paste0(dir,"visit_test.csv"), row.names = F)
```

```{r}

```

```{r}

```

```{r}

```

```{r}

```